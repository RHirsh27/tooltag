import Foundation
import PDFKit
import UIKit
import CoreText

final class ExportService {
    private let metrics: MetricsReporter
    private let fileManager = FileManager.default

    init(metrics: MetricsReporter) {
        self.metrics = metrics
    }

    @discardableResult
    func export(sop: SOP, format: ExportFormat, includeWatermark: Bool) async throws -> URL {
        await MainActor.run {
            metrics.track(event: .exportClicked, properties: ["format": format.rawValue])
        }

        let url: URL
        switch format {
        case .pdf:
            url = try exportPDF(sop: sop, isPro: includeWatermark == false)
        case .docx:
            url = try exportDOCX(sop: sop)
        case .markdown:
            let content = exportMarkdown(sop: sop)
            url = try write(content: content, fileName: "\(sop.id).md")
        }

        await MainActor.run {
            metrics.track(event: .exportSuccess, properties: ["format": format.rawValue])
        }
        return url
    }

    func exportPDF(sop: SOP, isPro: Bool) throws -> URL {
        let pageRect = CGRect(x: 0, y: 0, width: 612, height: 792)
        let textRect = pageRect.insetBy(dx: 40, dy: 40)
        let attributed = makeAttributedDocument(for: sop)
        let framesetter = CTFramesetterCreateWithAttributedString(attributed)
        let ranges = paginate(framesetter: framesetter, textLength: attributed.length, textRect: textRect)
        let renderer = UIGraphicsPDFRenderer(bounds: pageRect)

        let data = renderer.pdfData { context in
            for (pageIndex, range) in ranges.enumerated() {
                context.beginPage()
                draw(attributed: attributed, framesetter: framesetter, range: range, in: textRect, context: context.cgContext)
                if isPro == false {
                    drawWatermark(on: context.cgContext, in: pageRect)
                }
                drawFooter(on: context.cgContext, in: pageRect, pageNumber: pageIndex + 1, totalPages: ranges.count, isPro: isPro)
            }
        }

        return try write(data: data, fileName: "\(sop.id).pdf")
    }

    func exportMarkdown(sop: SOP) -> String {
        var lines: [String] = []
        
        // Title
        lines.append("# \(sop.title)")
        lines.append("")
        
        // Metadata
        if let summary = sop.summary, !summary.isEmpty {
            lines.append("## Summary")
            lines.append(summary)
            lines.append("")
        }
        
        // Tags
        if !sop.tags.isEmpty {
            lines.append("## Tags")
            lines.append(sop.tags.map { "`\($0)`" }.joined(separator: " "))
            lines.append("")
        }
        
        // Duration
        if let duration = sop.estimatedDurationMin {
            lines.append("## Estimated Duration")
            lines.append("\(duration) minutes")
            lines.append("")
        }
        
        // Tools
        if !sop.tags.isEmpty {
            lines.append("## Tools Needed")
            sop.tags.forEach { tool in
                lines.append("- \(tool)")
            }
            lines.append("")
        }
        
        // Steps
        lines.append("## Steps")
        lines.append("")
        
        sop.steps.sorted(by: { $0.order < $1.order }).forEach { step in
            lines.append("### \(step.order). \(step.title)")
            lines.append("")
            
            // Step details
            if let details = step.details, !details.isEmpty {
                lines.append(details)
                lines.append("")
            }
            
            // Duration
            if let duration = step.durationMin {
                lines.append("**Duration:** \(duration) minutes")
                lines.append("")
            }
            
            // Checklist items
            if !step.checklistItems.isEmpty {
                lines.append("**Checklist:**")
                lines.append("")
                step.checklistItems.forEach { item in
                    let checkbox = item.isRequired ? "- [ ] **\(item.text)**" : "- [ ] \(item.text)"
                    lines.append(checkbox)
                }
                lines.append("")
            }
            
            // Attachments
            if step.attachmentLocalURL != nil || step.voiceNoteLocalURL != nil {
                lines.append("**Attachments:**")
                if let attachmentURL = step.attachmentLocalURL {
                    lines.append("- ðŸ“Ž [File](\(attachmentURL.lastPathComponent))")
                }
                if let voiceURL = step.voiceNoteLocalURL {
                    lines.append("- ðŸŽ¤ [Voice Note](\(voiceURL.lastPathComponent))")
                }
                lines.append("")
            }
            
            lines.append("---")
            lines.append("")
        }
        
        // Footer
        lines.append("---")
        lines.append("*Generated by Processly*")
        
        return lines.joined(separator: "\n")
    }

    func exportDOCX(sop: SOP) throws -> URL {
        let attributed = makeAttributedDocument(for: sop)
        let range = NSRange(location: 0, length: attributed.length)
        let data = try attributed.data(
            from: range,
            documentAttributes: [
                .documentType: NSAttributedString.DocumentType.officeOpenXML,
                .characterEncoding: NSNumber(value: String.Encoding.utf8.rawValue)
            ]
        )
        return try write(data: data, fileName: "\(sop.id).docx")
    }

    // MARK: - PDF Helpers

    private func paginate(framesetter: CTFramesetter, textLength: Int, textRect: CGRect) -> [CFRange] {
        var ranges: [CFRange] = []
        var currentIndex: CFIndex = 0

        while currentIndex < textLength {
            let path = CGMutablePath()
            path.addRect(textRect)
            let range = CFRange(location: currentIndex, length: 0)
            let frame = CTFramesetterCreateFrame(framesetter, range, path, nil)
            let visible = CTFrameGetVisibleStringRange(frame)
            if visible.length == 0 {
                break
            }
            ranges.append(CFRange(location: currentIndex, length: visible.length))
            currentIndex += visible.length
        }

        if ranges.isEmpty {
            ranges.append(CFRange(location: 0, length: textLength))
        }

        return ranges
    }

    private func draw(attributed: NSAttributedString, framesetter: CTFramesetter, range: CFRange, in rect: CGRect, context: CGContext) {
        context.saveGState()
        context.textMatrix = .identity
        context.translateBy(x: rect.minX, y: rect.maxY)
        context.scaleBy(x: 1, y: -1)

        let path = CGMutablePath()
        path.addRect(CGRect(origin: .zero, size: CGSize(width: rect.width, height: rect.height)))
        let frame = CTFramesetterCreateFrame(framesetter, range, path, nil)
        CTFrameDraw(frame, context)

        context.restoreGState()
    }

    private func drawWatermark(on context: CGContext, in pageRect: CGRect) {
        let watermark = NSLocalizedString(Brand.watermarkFree, comment: "PDF watermark")
        context.saveGState()
        context.translateBy(x: pageRect.midX, y: pageRect.midY)
        context.rotate(by: -.pi / 4)
        let attributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.systemFont(ofSize: 32, weight: .bold),
            .foregroundColor: UIColor.systemGray.withAlphaComponent(0.2)
        ]
        let size = watermark.size(withAttributes: attributes)
        let origin = CGPoint(x: -size.width / 2, y: -size.height / 2)
        watermark.draw(at: origin, withAttributes: attributes)
        context.restoreGState()
    }

    private func drawFooter(on context: CGContext, in pageRect: CGRect, pageNumber: Int, totalPages: Int, isPro: Bool) {
        let footer = "Page \(pageNumber) of \(totalPages)"
        let attributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.preferredFont(forTextStyle: .footnote),
            .foregroundColor: UIColor.secondaryLabel
        ]
        let size = footer.size(withAttributes: attributes)
        let origin = CGPoint(x: pageRect.maxX - size.width - 40, y: pageRect.minY + 24)
        footer.draw(at: origin, withAttributes: attributes)
    }

    // MARK: - Attribution Builders

    private func makeAttributedDocument(for sop: SOP) -> NSMutableAttributedString {
        let document = NSMutableAttributedString()
        let isRTL = isRightToLeft(sop: sop)

        let headingStyle = NSMutableParagraphStyle()
        headingStyle.paragraphSpacing = 8
        headingStyle.baseWritingDirection = isRTL ? .rightToLeft : .leftToRight
        headingStyle.alignment = isRTL ? .right : .left

        let bodyStyle = NSMutableParagraphStyle()
        bodyStyle.lineBreakMode = .byWordWrapping
        bodyStyle.paragraphSpacing = 6
        bodyStyle.baseWritingDirection = headingStyle.baseWritingDirection
        bodyStyle.alignment = headingStyle.alignment

        let titleAttributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.preferredFont(forTextStyle: .title1),
            .paragraphStyle: headingStyle
        ]

        let sectionAttributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.preferredFont(forTextStyle: .headline),
            .paragraphStyle: headingStyle
        ]

        let bodyAttributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.preferredFont(forTextStyle: .body),
            .paragraphStyle: bodyStyle
        ]

        document.append(NSAttributedString(string: "\(sop.title)\n", attributes: titleAttributes))
        
        if let summary = sop.summary, !summary.isEmpty {
            document.append(NSAttributedString(string: "Summary\n", attributes: sectionAttributes))
            document.append(NSAttributedString(string: "\(summary)\n\n", attributes: bodyAttributes))
        }

        if !sop.tags.isEmpty {
            document.append(NSAttributedString(string: "Tags\n", attributes: sectionAttributes))
            document.append(NSAttributedString(string: sop.tags.joined(separator: ", ") + "\n\n", attributes: bodyAttributes))
        }

        if let duration = sop.estimatedDurationMin {
            document.append(NSAttributedString(string: "Estimated Duration\n", attributes: sectionAttributes))
            document.append(NSAttributedString(string: "\(duration) minutes\n\n", attributes: bodyAttributes))
        }

        document.append(NSAttributedString(string: "Steps\n", attributes: sectionAttributes))
        sop.steps.sorted(by: { $0.order < $1.order }).forEach { step in
            var line = "\(step.order). \(step.title)"
            if let minutes = step.durationMin {
                line += " (\(minutes)m)"
            }
            document.append(NSAttributedString(string: line + "\n", attributes: bodyAttributes))
            
            if let details = step.details, !details.isEmpty {
                document.append(NSAttributedString(string: "   \(details)\n", attributes: bodyAttributes))
            }
            
            if !step.checklistItems.isEmpty {
                document.append(NSAttributedString(string: "   Checklist:\n", attributes: bodyAttributes))
                step.checklistItems.forEach { item in
                    let prefix = item.isRequired ? "   â€¢ " : "   - "
                    document.append(NSAttributedString(string: "\(prefix)\(item.text)\n", attributes: bodyAttributes))
                }
            }
            
            if step.attachmentLocalURL != nil || step.voiceNoteLocalURL != nil {
                document.append(NSAttributedString(string: "   Attachments: ", attributes: bodyAttributes))
                var attachments: [String] = []
                if step.attachmentLocalURL != nil {
                    attachments.append("File")
                }
                if step.voiceNoteLocalURL != nil {
                    attachments.append("Voice Note")
                }
                document.append(NSAttributedString(string: attachments.joined(separator: ", ") + "\n", attributes: bodyAttributes))
            }
        }

        return document
    }

    private func isRightToLeft(sop: SOP) -> Bool {
        let combined = [sop.title, sop.summary] + sop.steps.map { $0.instruction + (" " + ($0.notes ?? "")) }
        let scalars = combined.joined().unicodeScalars
        let rtlRanges: [ClosedRange<UInt32>] = [0x0590...0x08FF]
        return scalars.contains { scalar in
            rtlRanges.contains { $0.contains(UInt32(scalar.value)) }
        }
    }

    // MARK: - File Helpers

    private func write(content: String, fileName: String) throws -> URL {
        guard let data = content.data(using: .utf8) else {
            throw ExportError.writeFailed
        }
        return try write(data: data, fileName: fileName)
    }

    private func write(data: Data, fileName: String) throws -> URL {
        let url = fileManager.temporaryDirectory.appendingPathComponent(fileName)
        if fileManager.fileExists(atPath: url.path) {
            try fileManager.removeItem(at: url)
        }
        do {
            try data.write(to: url, options: .atomic)
            return url
        } catch {
            throw ExportError.writeFailed
        }
    }
}

enum ExportError: Error {
    case writeFailed
}
